[{"name": "app.py", "content": "##shiny run --reload --launch-browser Documents/GitHub/dynamics_random_complex_systems/ds_shiny/app.py\n\n########################################################\n\n##Part A: load in the libraries and functions for running the code\n\n##libraries\n\nimport random\nfrom random import randint\nimport numpy as np\nimport csv\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nimport networkx as nx\n\nimport scipy as sp\nfrom scipy.integrate import solve_ivp\n\nfrom shiny import reactive, Inputs, ui, App, render\n\n###############################################################\n\napp_ui = ui.page_sidebar(\n\n    ui.sidebar(\n    \n    ui.div(\n        ui.input_action_button(\n            \"run\", \"Run this model\", class_=\"btn-primary\"\n        ),\n        \n    ),\n    \n    ui.div(\n        \n        ui.input_action_button(\n            \"reset_model\", \"Reset the model\", class_=\"btn-primary\"\n        ),\n        \n    ),\n    \n    ui.input_radio_buttons(\"run_type\", \"Type of run\", choices=[\"Random\", \"Intuitive\", \"Counter-intuitive\"]),\n    \n    ui.input_slider(\"prop_interactions\", \"Prop. of possible interactions\", 0, 1, 0.5),\n    \n    ui.input_radio_buttons(\"parameter_to_update\", \"Parameter to update\", choices=[\"None\", \"Value\", \"Max level\", \"Interaction\"]),\n    \n    ui.input_slider(\"sel_node\", \"Selected node\", 0, 15, 0, step = 1),\n    \n    ui.input_slider(\"sel_other_node\", \"Interaction from...\", 0, 15, 1, step = 1),\n    \n    ui.input_slider(\"no_factors\", \"No. factors\", 1, 15, 5, step = 1),\n    \n    ui.input_slider(\"kick_size\", \"Kick size\", -2, 2, 0.1, step = 0.1),\n    \n    ui.input_slider(\"max_time\", \"Maximum time\", 0, 50, 20, step = 1),\n    \n    ),\n    \n    ui.output_plot(\"Plot_Model_Output\"),\n    \n)\n\n###############################################################\n\n\ndef server(input, output, session):\n    \n        \n    @render.plot\n    # ignore_none=False is used to instruct Shiny to render this plot even before the\n    # input.run button is clicked for the first time. We do this because we want to\n    # render the empty 3D space on app startup, to give the user a sense of what's about\n    # to happen when they run the simulation.\n    @reactive.event(input.run, ignore_none=True)\n\n    def Plot_Model_Output():\n        \n        ##initialise the factors\n        \n        kick_size=input.kick_size()\n        \n        no_t=500\n        \n        no_factors=input.no_factors()\n        \n        sel_node=int(input.sel_node())\n        \n        sel_other_node=int(input.sel_other_node())\n        \n        np.random.seed(100*input.reset_model())\n        \n        growth_rate=np.random.random(no_factors)*2\n\n        growth_to_max_rate=np.random.random(no_factors)*2\n\n        max_resources=np.random.random(no_factors)*2\n\n        initial_interactions=np.random.random([no_factors, no_factors])*2-1\n        \n        ##create an array that tells us which interactions to include\n        \n        interactions_include=(np.random.choice([0, 1], no_factors*no_factors, p=[1-input.prop_interactions(), input.prop_interactions()])).reshape(no_factors, no_factors)\n        \n        interactions=initial_interactions*interactions_include\n        \n        for i in np.arange(no_factors):\n\n            interactions[i,i]=0\n            \n        print(\"interactions\")\n        \n        print(interactions)\n\n        def Calc_x_dot(x):\n\n            x_dot=np.zeros(no_factors)\n\n            for sel_ind in np.arange(no_factors):\n\n                x_growth=x[sel_ind]*growth_rate[sel_ind]\n\n                x_logistic_growth=growth_to_max_rate[sel_ind]*max_resources[sel_ind]-x[sel_ind]\n\n                for sel_other_ind in np.arange(no_factors):\n                \n                    x_logistic_growth=x_logistic_growth+interactions[sel_other_ind, sel_ind]*x[sel_other_ind]\n                    \n                x_dot[sel_ind]=x_growth*x_logistic_growth\n                    \n            return(x_dot)\n\n        def Behaviour_Model_ODE(t, x):#, alpha, beta, gamma, delta, epsilon):\n\n            x_dot=Calc_x_dot(x)\n            \n            return(x_dot)\n            \n    \t##Some default settings to investigate\n    \t\n        if input.run_type()==\"Intuitive\":\n           \t\n                no_factors=5\n                \n                growth_rate=np.ones(no_factors)*2\n\n                growth_to_max_rate=np.zeros(no_factors)\n\n                max_resources=np.zeros(no_factors)\n\n                interactions=np.zeros([no_factors, no_factors])\n                \n                growth_to_max_rate[3]=1\n                \n                growth_to_max_rate[4]=1\n                \n                max_resources[3]=1\n                \n                max_resources[4]=1\n                \n                interactions[2, 0]=2\n                \n                interactions[4, 2]=2\n               \n                interactions[3, 0]=2\n                \n                interactions[3, 1]=1\n                \n                interactions[1, 0]=-1\n                \n        if input.run_type()==\"Counter-intuitive\":\n           \t\n                no_factors=5\n                \n                growth_rate=np.ones(no_factors)*2\n\n                growth_to_max_rate=np.zeros(no_factors)\n\n                max_resources=np.zeros(no_factors)\n\n                interactions=np.zeros([no_factors, no_factors])\n                \n                growth_to_max_rate[3]=1\n                \n                growth_to_max_rate[4]=1\n                \n                max_resources[3]=1\n                \n                max_resources[4]=1\n                \n                interactions[2, 0]=2\n                \n                interactions[4, 2]=2\n               \n                interactions[3, 0]=0.5\n                \n                interactions[3, 1]=1\n                \n                interactions[1, 0]=-1\n\n\n        #single_kick_data=Single_Behaviour_Kick(kick_size, no_factors, no_t, 1)\n\n        t_max=0\n            \n        single_kick_data=[]\n\n        x_init=np.random.random(no_factors)*0.4\n                \n        full_z=np.reshape(x_init,(no_factors,1))\n\n        print(full_z)\n\n        full_t=[0]\n\n        print(full_t)\n\n        nudge_behaviour=0\n                \n        t_min=0\n\n        t_max=int(input.max_time()/2)\n\n        t_sol=np.linspace(t_min, t_max, no_t)\n                \n        sol=solve_ivp(Behaviour_Model_ODE, [np.min(t_sol), np.max(t_sol)], x_init, dense_output=True, t_eval=t_sol)\n\n        z=sol.sol(t_sol)\n\n        full_z=np.hstack([full_z,z])\n                \n        full_t=np.hstack([full_t,t_sol])\n\n        L=len(z[0,:])\n\n        x_init=z[:,L-1]\n\n        single_kick_data=np.hstack([single_kick_data, x_init[[0, 1]]])\n\n        ######\n\n        ##nudge the system\n\n        if input.parameter_to_update()==\"Value\":\n\n            x_init[sel_node]=x_init[sel_node]+kick_size#np.random.random(2)*2\n            \n        if input.parameter_to_update()==\"Max level\":\n\n            max_resources[sel_node]=max_resources[sel_node]+kick_size#np.random.random(2)*2\n            \n        if input.parameter_to_update()==\"Interaction\":\n\n            interactions[sel_other_node, sel_node]=interactions[sel_other_node, sel_node]+kick_size#np.random.random(2)*2\n\n        #######\n\n        ##run for another half of the time to see what happens\n\n        t_min=int(input.max_time()/2)\n\n        t_max=int(input.max_time())\n\n        t_sol=np.linspace(t_min, t_max, no_t)\n                \n        sol=solve_ivp(Behaviour_Model_ODE, [np.min(t_sol), np.max(t_sol)], x_init, dense_output=True, t_eval=t_sol)\n\n        print(\"sol\")\n\t\n        print(sol)\n\n        z=sol.sol(t_sol)\n\n        full_z=np.hstack([full_z,z])\n                \n        full_t=np.hstack([full_t,t_sol])\n     \n        fig, ax = plt.subplots(nrows=1, ncols=2)\n        \n        for sel_factor in np.arange(no_factors):\n        \n                set_line_width=1\n                \n                if sel_factor==0:\n                \n                        set_line_width=3\n\n                ax[0].plot(full_t, full_z.T[:, sel_factor], linewidth=set_line_width, label=f\"{sel_factor}\")\n                \n        ax[0].legend(bbox_to_anchor=(1, -0.1), ncol=no_factors)\n\n        #############################################################\n\n        ##plot the connecting networkx\n\n        seed = 13648  # Seed random number generators for reproducibility\n        #G = nx.random_k_out_graph(10, 3, 0.5, seed=seed)\n\n        G = nx.DiGraph(interactions)\n\n        #pos = nx.spring_layout(G, seed=seed)\n        \n        pos = nx.circular_layout(G, scale=2)\n\n        node_sizes = 200#200*(1+max_resources/np.sum(max_resources))\n        M = G.number_of_edges()\n\n        all_edge_colors = np.reshape(interactions, (len(interactions[:,0])*len(interactions[:,0]), 1))\n\n        edge_colors=all_edge_colors[all_edge_colors!=0]\n\n        cmap = plt.cm.plasma\n\n        nodes = nx.draw_networkx_nodes(G, pos, node_size=node_sizes, node_color=\"white\", edgecolors=\"black\")\n\n        edges = nx.draw_networkx_edges(\n            G,\n            pos,\n            node_size=node_sizes,\n            arrowstyle=\"->\",\n            arrowsize=10,\n            edge_color=edge_colors,\n            edge_cmap=cmap,\n            width=2,\n            connectionstyle='arc3,rad=0.1'\n        )\n\n        labels=nx.draw_networkx_labels(G, pos=pos)\n\n        pc = mpl.collections.PatchCollection(edges, cmap=cmap)\n        pc.set_array(edge_colors)\n\n        ax[1] = plt.gca()\n        ax[1].set_axis_off()\n        plt.colorbar(pc, ax=ax[1])\n\n        #plt.show()\n                \n        #fig.savefig(\"single_kick.png\")\n                \n        #plt.close()\n\n        #nx.draw(G, edge_color=interactions+np.min(interactions)+0.01)\n\n        #plt.show()\n\n        #plt.close()\n        \n        return fig\n     \n     \napp = App(app_ui, server)\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "type": "text"}, {"name": "app_v1.py", "content": "##shiny run --reload --launch-browser GitHub/dynamics_random_complex_systems/ds_shiny/app.py\n\n########################################################\n\n##Part A: load in the libraries and functions for running the code\n\n##libraries\n\nimport random\nfrom random import randint\nimport numpy as np\nimport csv\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nimport networkx as nx\n\nimport scipy as sp\nfrom scipy.integrate import solve_ivp\n\nfrom shiny import reactive, Inputs, ui, App, render\n\n###############################################################\n\napp_ui = ui.page_sidebar(\n\n    ui.sidebar(\n    \n    ui.input_radio_buttons(\"run_type\", \"Type of run\", choices=[\"Random\", \"Intuitive\", \"Counter-intuitive\"]),\n    \n    ui.input_radio_buttons(\"repeat\", \"New run?\", choices=[\"New\", \"Continue\"]),\n    \n    ui.input_radio_buttons(\"parameter_to_update\", \"Parameter to update\", choices=[\"Value\", \"Max level\", \"Interaction\"]),\n    \n    ui.input_text(\"sel_node\", \"Selected node\", \"Enter selected node...\"),\n    \n    ui.input_text(\"value_change\", \"Value change\", \"Enter change...\"),\n    \n    ui.input_text(\"max_change\", \"Max value change\", \"Enter change...\"),\n    \n    ui.input_text(\"sel_other_node\", \"Selected other node\", \"Enter selected other node...\"),\n    \n    ui.input_text(\"interaction_change\", \"Interaction change\", \"Enter change...\"),\n    \n    ui.div(\n        ui.input_action_button(\n            \"run\", \"Update output\", class_=\"btn-primary\"\n        ),\n        \n    ),\n \n    ),\n    \n    ui.output_plot(\"Plot_Model_Output\"),\n    \n)\n\n###############################################################\n\n\ndef server(input, output, session):\n    \n    kick_size=0.1\n\t\n    no_factors=5\n\n    no_t=250\n    \n    growth_rate=np.random.random(no_factors)*2\n\n    growth_to_max_rate=np.random.random(no_factors)*2\n\n    max_resources=np.random.random(no_factors)*2\n\n    interactions=np.random.random([no_factors, no_factors])*2-1\n\n    for i in np.arange(no_factors):\n\n        interactions[i,i]=0\n    \n    \n    @reactive.calc()\n    def Run_The_Shiny_Model():\n\n        growth_rate=np.random.random(no_factors)*2\n\n        growth_to_max_rate=np.random.random(no_factors)*2\n\n        max_resources=np.random.random(no_factors)*2\n\n        interactions=np.random.random([no_factors, no_factors])*2-1\n\n        for i in np.arange(no_factors):\n\n            interactions[i,i]=0\n\n        print(\"growth_rate = \", growth_rate)\n\n        print(\"growth_to_max_rate = \", growth_to_max_rate)\n\n        print(\"max_resources = \", max_resources)\n\n        print(\"interactions = \", interactions)\n        \n        def Calc_x_dot(x):\n\n            x_dot=np.zeros(no_factors)\n\n            for sel_ind in np.arange(no_factors):\n\n                x_growth=x[sel_ind]*growth_rate[sel_ind]\n\n                x_logistic_growth=growth_to_max_rate[sel_ind]*max_resources[sel_ind]-x[sel_ind]\n\n                for sel_other_ind in np.arange(no_factors):\n                \n                    x_logistic_growth=x_logistic_growth+interactions[sel_ind, sel_other_ind]*x[sel_other_ind]\n                    \n                x_dot[sel_ind]=x_growth*x_logistic_growth\n                    \n            return(x_dot)\n\n        def Behaviour_Model_ODE(t, x):#, alpha, beta, gamma, delta, epsilon):\n\n            x_dot=Calc_x_dot(x)\n            \n            return(x_dot)\n            \n\n\n        #single_kick_data=Single_Behaviour_Kick(kick_size, no_factors, no_t, 1)\n\n        t_max=0\n            \n        single_kick_data=[]\n\n        x_init=np.random.random(no_factors)*0.4\n                \n        full_z=np.reshape(x_init,(no_factors,1))\n\n        print(full_z)\n\n        full_t=[0]\n\n        print(full_t)\n\n        nudge_behaviour=0\n                \n        t_min=t_max\n\n        t_max=t_max+10\n\n        t_sol=np.linspace(t_min, t_max, no_t)\n                \n        sol=solve_ivp(Behaviour_Model_ODE, [np.min(t_sol), np.max(t_sol)], x_init, dense_output=True, t_eval=t_sol)\n\n        z=sol.sol(t_sol)\n\n        full_z=np.hstack([full_z,z])\n                \n        full_t=np.hstack([full_t,t_sol])\n\n        L=len(z[0,:])\n\n        x_init=z[:,L-1]\n\n        single_kick_data=np.hstack([single_kick_data, x_init[[0, 1]]])\n\n        ######\n\n        ##nudge the system\n\n        nudge_behaviour=1\n\n\n        x_init[0]=x_init[0]+nudge_behaviour*kick_size#np.random.random(2)*2\n\n        #######\n\n        ##run for another 10 seconds to see what happens\n\n        t_min=t_max\n\n        t_max=t_max+10\n\n        t_sol=np.linspace(t_min, t_max, no_t)\n                \n        sol=solve_ivp(Behaviour_Model_ODE, [np.min(t_sol), np.max(t_sol)], x_init, dense_output=True, t_eval=t_sol)\n\n        z=sol.sol(t_sol)\n\n        full_z=np.hstack([full_z,z])\n                \n        full_t=np.hstack([full_t,t_sol])\n\n        L=len(z[0,:])\n\n        x_init=z[:,L-1]\n\n        single_kick_data=np.hstack([single_kick_data, x_init[[0, 1]]])\n\n        print(\"single_kick_data\")\n\n        print(single_kick_data)\n        \n        all_outputs=[full_z, full_t]\n        \n        return(all_outputs)\n        \n    @render.plot\n    # ignore_none=False is used to instruct Shiny to render this plot even before the\n    # input.run button is clicked for the first time. We do this because we want to\n    # render the empty 3D space on app startup, to give the user a sense of what's about\n    # to happen when they run the simulation.\n    @reactive.event(input.run, ignore_none=True)\n\n    def Plot_Model_Output():\n        \n        ##initialise the factors\n    \n#        growth_rate=np.random.random(no_factors)*2\n#\n #       growth_to_max_rate=np.random.random(no_factors)*2\n#\n #       max_resources=np.random.random(no_factors)*2\n#\n #       interactions=np.random.random([no_factors, no_factors])*2-1\n#\n #       for i in np.arange(no_factors):\n#\n #           interactions[i,i]=0\n        \n        all_outputs=Run_The_Shiny_Model()\n        \n        full_z=all_outputs[0]\n\n        full_t=all_outputs[1]\n        \n        fig, ax = plt.subplots(nrows=1, ncols=2)\n\n        ax[0].plot(full_t, full_z.T)\n\n        #############################################################\n\n        ##plot the connecting networkx\n\n#        seed = 13648  # Seed random number generators for reproducibility\n        #G = nx.random_k_out_graph(10, 3, 0.5, seed=seed)\n\n        G = nx.DiGraph(interactions)\n\n        pos = nx.spring_layout(G)#, seed=seed)\n\n        node_sizes = 200*(1+max_resources/np.sum(max_resources))\n        M = G.number_of_edges()\n\n        all_edge_colors = np.reshape(interactions, (len(interactions[:,0])*len(interactions[:,0]), 1))\n\n        edge_colors=all_edge_colors[all_edge_colors!=0]\n\n        cmap = plt.cm.plasma\n\n        nodes = nx.draw_networkx_nodes(G, pos, node_size=node_sizes, node_color=\"white\", edgecolors=\"black\")\n\n        edges = nx.draw_networkx_edges(\n            G,\n            pos,\n            node_size=node_sizes,\n            arrowstyle=\"->\",\n            arrowsize=10,\n            edge_color=edge_colors,\n            edge_cmap=cmap,\n            width=2,\n            connectionstyle='arc3,rad=0.1'\n        )\n\n        labels=nx.draw_networkx_labels(G, pos=pos)\n\n        pc = mpl.collections.PatchCollection(edges, cmap=cmap)\n        pc.set_array(edge_colors)\n\n        ax[1] = plt.gca()\n        ax[1].set_axis_off()\n        plt.colorbar(pc, ax=ax[1])\n\n        #plt.show()\n                \n        #fig.savefig(\"single_kick.png\")\n                \n        #plt.close()\n\n        #nx.draw(G, edge_color=interactions+np.min(interactions)+0.01)\n\n        #plt.show()\n\n        #plt.close()\n        \n        return fig\n     \n     \napp = App(app_ui, server)\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "type": "text"}]